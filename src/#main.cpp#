#include <cstdlib>
#include <cstdio>
#include <time.h>
#include <raylib.h>
#include "include/gtd.h"
#define WINDOW_WIDTH 486
#define WINDOW_HEIGHT 486
#define GRID_START 100
const Color BackGroundColor{
  .r = 192,
  .g = 192,
  .b = 192,
  .a = 255,
};

Vector2 SqaureSize{
    .x = 54,
    .y = 54,
};
struct RestartButton_t {
  Rectangle RestartRect{
      .x = (WINDOW_WIDTH / 2.0f) - (67.5 / 2.0f),
      .y = (100 / 2.0f) - (67.5 / 2.0f),
      .width = 67.5,
      .height = 67.5,
  };
  bool Pressed = false;
  bool Dead = false; // this is the game over con
  bool Won = false;
};
struct Vector2I{
  int x,y;
};

RestartButton_t RestartButton;
// used for the snpritnf
char NumberBuffer[4];

Texture2D DefaultBoxTexture;

Texture2D PressedBoxTexture;

Texture2D EvilMineCat;

Texture2D YellowCatAlive;

Texture2D YellowCatDead;

Texture2D YellowCatWon;

Texture2D YellowCatDeadPressed;

Texture2D YellowCatAlivePressed;

struct Cell {
  bool IsAMine = false;
  bool Pressed = false;
  Vector2 postion;
  int MinesInArea;
};



// can be scaled in the future for now just assume 9x9 grid
Cell MineGrid[9][9];

int NonMinesLeft = (sizeof(MineGrid) / sizeof(Cell)) - 10;

inline void render_restart_button();

void generate_random_mines();

void flood_fill(int Sx, int Sy);

void init_mine_grid();

inline void handle_cell_texture(Cell current_cell,Rectangle TextureSource,Rectangle concated_shape);

void load_assests();

void unload_assests();

void render_game_state();

void calculate_mines_in_area(int in, int total_mines);

void handle_resize();


int main(void) {
  init_mine_grid();
  InitWindow(486, 586, "KittenSweeper! :3");
  SetTargetFPS(60);
  load_assests();
  BeginDrawing();
  ClearBackground(BackGroundColor);
  render_game_state();
  EndDrawing();
  for (; !WindowShouldClose();) {
	BeginDrawing();
    if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {
	  Vector2 mouse_pos = GetMousePosition();
	  if (!RestartButton.Dead && mouse_pos.y >= 100){
		 int gridX = int((mouse_pos.x / SqaureSize.x));
		 int gridY = int(((mouse_pos.y - 100) / SqaureSize.y));
		 MineGrid[gridY][gridX].Pressed = true;
		 if (MineGrid[gridY][gridX].IsAMine) {
		   RestartButton.Dead = true;
		 }
		 if(MineGrid[gridY][gridX].MinesInArea == 0){
		   flood_fill(gridX, gridY);
		 }else{
		   NonMinesLeft--;
		 }
	  }
	  else if(mouse_pos.x <= (RestartButton.RestartRect.width + RestartButton.RestartRect.x) && mouse_pos.x >= (RestartButton.RestartRect.x)){
		if(mouse_pos.y <= (RestartButton.RestartRect.y + RestartButton.RestartRect.height) && mouse_pos.y >= RestartButton.RestartRect.y){
		  RestartButton.Pressed = true;
		  init_mine_grid();
		  RestartButton.Dead = false;
		}
	  }
	  //render_game_state(); // this was causing flickering on macos so i just have it render on each loop.
    }
    if (IsKeyPressed(KEY_Q)) {
	  break;
    }
	render_game_state();
   EndDrawing();
  }
  unload_assests();
  CloseWindow();
  return 0;
}

void render_game_state() {
  ClearBackground(BackGroundColor);
  const Rectangle TextureSource{
      .x = 0,
      .y = 0,
      .width = float(DefaultBoxTexture.width),
      .height = float(DefaultBoxTexture.height),
  };
  render_restart_button();
  for (int I = 0; I < 9; I++) {
    for (int i = 0; i < 9; i++) {
	  Cell current_cell = MineGrid[I][i];
          Rectangle concated_shape = {
              .x = current_cell.postion.x,
              .y = current_cell.postion.y,
              .width = SqaureSize.y,
              .height = SqaureSize.x,
          };
	 if (current_cell.Pressed){
	  handle_cell_texture(current_cell,TextureSource,concated_shape);
    } else {
      DrawTexturePro(DefaultBoxTexture, TextureSource, concated_shape,
                     Vector2{0.0, 0.0}, 0.0f, WHITE);
   }
	 // debug for mine calculation
	 char debug_buffer[40];
	  if (current_cell.IsAMine) {
		DrawText("M",(current_cell.postion.x),(current_cell.postion.y),20,RED);
      } else {
        snprintf(debug_buffer, sizeof(debug_buffer), "%d",
                      current_cell.MinesInArea);
		DrawText(debug_buffer,(current_cell.postion.x),(current_cell.postion.y),20,GREEN);
      }
	  snprintf(debug_buffer, sizeof(debug_buffer), "Non Mines Remaing%d",NonMinesLeft);
	  DrawText(debug_buffer,0,0,20,RED);
    }
  }
}
// don't know if the inline keyword actually does anything on modern compilers?
// made this a seperate function so the render loop isn't as verbose
inline void handle_cell_texture(Cell current_cell,Rectangle TextureSource,Rectangle concated_shape) {
  if (current_cell.IsAMine) {
    Rectangle MineTextureSource {
      .x = 0, .y = 0,
	  .width = float(EvilMineCat.width),.height = float(EvilMineCat.height),
    };
    DrawTexturePro(EvilMineCat, MineTextureSource, concated_shape,
                   Vector2{0.0, 0.0}, 0.0f, WHITE);
	return;
  }
  // TODO alssya is working on custom number assests for me. For now I'm just
  // going to print the number as text for now
  DrawTexturePro(PressedBoxTexture, TextureSource, concated_shape,
                 Vector2{0.0, 0.0}, 0.0f, WHITE);
  snprintf(NumberBuffer, sizeof(NumberBuffer), "%d", current_cell.MinesInArea);
  DrawText(NumberBuffer,concated_shape.x + (concated_shape.width / 2),concated_shape.y + (concated_shape.height / 2),20,RED);
}
inline void render_restart_button() {
    const Rectangle RestartButtonSource{
      .x = 0,
      .y = 0,
      .width = float(YellowCatAlive.width),
      .height = float(YellowCatAlive.height),
  	};
    if (RestartButton.Dead) {
      DrawTexturePro(YellowCatDead, RestartButtonSource,
                     RestartButton.RestartRect, Vector2{0.0f, 0.0f}, 0.0f,
                     WHITE);
	  return;
    }
	if(RestartButton.Won){
	 DrawTexturePro(YellowCatWon, RestartButtonSource,
                     RestartButton.RestartRect, Vector2{0.0f, 0.0f}, 0.0f,
                     WHITE);
	 return;
	}
	  
	if (RestartButton.Pressed){
	  DrawTexturePro(YellowCatAlivePressed, RestartButtonSource,
                     RestartButton.RestartRect, Vector2{0.0f, 0.0f}, 0.0f,
                     WHITE);
	}
	DrawTexturePro(YellowCatAlive, RestartButtonSource,
                         RestartButton.RestartRect, Vector2{0.0f, 0.0f}, 0.0f,
					 WHITE);
	
	
}
// in the future this will have to load a larger amount of assests
void load_assests() {
  DefaultBoxTexture = LoadTexture("./src/assests/defaultunpressed.png");
  PressedBoxTexture = LoadTexture("./src/assests/defaultpressed.png");
  EvilMineCat = LoadTexture("./src/assests/evilcatpressed.png");
  YellowCatAlive = LoadTexture("./src/assests/yellowcatun.png");
  YellowCatAlivePressed = LoadTexture("./src/assests/yellowcatpr.png");
  YellowCatDead = LoadTexture("./src/assests/deadyellowcat.png");
  YellowCatWon = LoadTexture("./src/assests/coolyellowcatun.png");
}
void unload_assests() {
  UnloadTexture(DefaultBoxTexture);
  UnloadTexture(PressedBoxTexture);
  UnloadTexture(EvilMineCat);
  UnloadTexture(YellowCatAlive);
  UnloadTexture(YellowCatAlivePressed);
  UnloadTexture(YellowCatDead);
}

//default is to start going to the right
void flood_fill(int Sx, int Sy){
  Vector2I cord_queue[71];
  Vector2i cord_map[71];
  int qp = 0;
  int ql = 1;
  cord_queue[0].x = Sx;
  cord_queue[0].y = Sy;
  
  for(;qp < ql;qp++){
	Vector2I current_cords = cord_queue[qp];
	if(current_cords.x){
	  MineGrid[current_cords.y][current_cords.x -1].Pressed = true;
	  if(MineGrid[current_cords.y][current_cords.x -1].MinesInArea == 0){
		cord_queue[ql].x = current_cords.x - 1;
		cord_queue[ql].y = current_cords.y;
		ql++;
	  }
	}
	if(current_cords.y){
	  MineGrid[current_cords.y - 1][current_cords.x].Pressed = true;
	  if( MineGrid[current_cords.y - 1][current_cords.x].MinesInArea == 0 ){
		cord_queue[ql].x = current_cords.x;
		cord_queue[ql].y = current_cords.y - 1;
		ql++;
	  }
	}
	if(current_cords.x != 8){
	  MineGrid[current_cords.y][current_cords.x + 1].Pressed = true;
	  if(MineGrid[current_cords.y][current_cords.x + 1].MinesInArea == 0){
		cord_queue[ql].x = current_cords.x + 1;
		cord_queue[ql].y = current_cords.y;
		ql++;
	  }
	}
	if(current_cords.y != 8){
	  MineGrid[current_cords.y + 1][current_cords.x].Pressed = true;
	  if(MineGrid[current_cords.y + 1][current_cords.x].MinesInArea == 0){
		cord_queue[ql].x = current_cords.x;
		cord_queue[ql].y = current_cords.y + 1;
		ql++;
	  
	}
  }

  }
}
bool check_queue(Vector2I *queue, int ql,Vector2I cords){
  for(int i = 0; i < ql; i++){
	
  }
}

void insert_map(Vector2I *map, int map_cap,Vector2i cords,int index){
  
}

void generate_random_mines(int in,int total_mines) {
  int counter = in;
  int RandRow = rand() % 9;
  int RandCol = rand() % 9;
  if (MineGrid[RandRow][RandCol].IsAMine) {
	return generate_random_mines(counter,total_mines);
  }
  MineGrid[RandRow][RandCol].IsAMine = true;
  counter++;
  if (counter < total_mines) {
	return generate_random_mines(counter,total_mines);
  }
  return;
}
// I could of probably done this better -- i did end up doing it better
void calculate_mines_in_area() {
  for (int I = 0; I < 9; I++) {
    for (int i = 0; i < 9; i++) {
      Cell current_cell = MineGrid[I][i];
	  if(!current_cell.IsAMine){
		continue;
	  }
	 if(I){
	   MineGrid[I-1][i].MinesInArea++;
	 }
	 if(i){
	   MineGrid[I][i - 1].MinesInArea++;  
	 }
	 if(I != 8){
	   MineGrid[I+1][i].MinesInArea++;
	 }
	 if(i != 8){
	   MineGrid[I][i+1].MinesInArea++; 
	 }
	 if(I && i){
	   MineGrid[I-1][i-1].MinesInArea++;
	 }
	 if(I != 8 && i != 8){
	   MineGrid[I+1][i+1].MinesInArea++;
	 }
	 if(I != 8 && i){
	   MineGrid[I + 1][i-1].MinesInArea++;
	 }
	 if(I && i != 8){
	   MineGrid[I - 1][i + 1].MinesInArea++;
	 }
 	}
  }
}
void init_mine_grid() {
  int X = 0;
  int Y = GRID_START;
  
  for (int I = 0; I < 9; I++) {
    for (int i = 0; i < 9; i++) {
      MineGrid[I][i].postion = Vector2{.x = float(X), .y = float(Y)};
	  MineGrid[I][i].Pressed = false;
	  MineGrid[I][i].IsAMine = false;
	  MineGrid[I][i].MinesInArea = 0;
	  X += SqaureSize.x;
    }
    X = 0;
	Y += SqaureSize.y;
  }
  srand(time(0));
  generate_random_mines(0,10);
  calculate_mines_in_area();
} 
